'use strict';

var tslib_es6 = require('../../node_modules/tslib/tslib.es6.js');
var React = require('react');
var PropTypes = require('prop-types');
var index = require('../../_virtual/index.js');
require('@popperjs/core');
var isRTL = require('../../utils/isRTL.js');
var useForkedRef = require('../../hooks/useForkedRef.js');
var utils = require('./utils.js');

var CRangeSlider = React.forwardRef(function (_a, ref) {
    var className = _a.className, _b = _a.clickableLabels, clickableLabels = _b === void 0 ? true : _b, _c = _a.disabled, disabled = _c === void 0 ? false : _c, _d = _a.distance, distance = _d === void 0 ? 0 : _d, labels = _a.labels, _e = _a.min, min = _e === void 0 ? 0 : _e, _f = _a.max, max = _f === void 0 ? 100 : _f, name = _a.name, _g = _a.step, step = _g === void 0 ? 1 : _g, _h = _a.value, value = _h === void 0 ? [] : _h, onChange = _a.onChange, _j = _a.tooltips, tooltips = _j === void 0 ? true : _j, tooltipsFormat = _a.tooltipsFormat, _k = _a.track, track = _k === void 0 ? 'fill' : _k, _l = _a.vertical, vertical = _l === void 0 ? false : _l, rest = tslib_es6.__rest(_a, ["className", "clickableLabels", "disabled", "distance", "labels", "min", "max", "name", "step", "value", "onChange", "tooltips", "tooltipsFormat", "track", "vertical"]);
    var rangeSliderRef = React.useRef(null);
    var forkedRef = useForkedRef.useForkedRef(ref, rangeSliderRef);
    var inputsRef = React.useRef([]);
    var labelsContainerRef = React.useRef(null);
    var labelsRef = React.useRef([]);
    var trackRef = React.useRef(null);
    var _m = React.useState(Array.isArray(value) ? value : [value]), currentValue = _m[0], setCurrentValue = _m[1];
    var _o = React.useState(false), isDragging = _o[0], setIsDragging = _o[1];
    var _p = React.useState(false), _isRTL = _p[0], setIsRTL = _p[1];
    var _q = React.useState(0), dragIndex = _q[0], setDragIndex = _q[1];
    var _r = React.useState(), thumbSize = _r[0], setThumbSize = _r[1];
    React.useEffect(function () {
        setCurrentValue(Array.isArray(value) ? value : [value]);
    }, [value]);
    React.useEffect(function () {
        if (rangeSliderRef.current) {
            setIsRTL(isRTL.default(rangeSliderRef.current));
            setThumbSize(utils.getThumbSize(rangeSliderRef.current, vertical));
        }
    }, [rangeSliderRef]);
    React.useEffect(function () {
        var maxSize = Math.max.apply(Math, labelsRef.current.map(function (label) { return (vertical ? label.offsetWidth : label.offsetHeight); }));
        if (labelsContainerRef.current) {
            labelsContainerRef.current.style[vertical ? 'width' : 'height'] = "".concat(maxSize, "px");
        }
    }, [labelsRef]);
    React.useEffect(function () {
        if (isDragging) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        return function () {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [currentValue]);
    var updateNearestValue = function (value) {
        var nearestIndex = utils.getNearestValueIndex(value, currentValue);
        var newCurrentValue = tslib_es6.__spreadArray([], currentValue, true);
        newCurrentValue[nearestIndex] = utils.validateValue(value, currentValue, distance, nearestIndex);
        setTimeout(function () {
            inputsRef.current[nearestIndex].focus();
        });
        setCurrentValue(newCurrentValue);
        if (onChange) {
            onChange(newCurrentValue);
        }
    };
    var handleInputChange = function (event, index) {
        setIsDragging(false);
        var target = event.target;
        var value = Number(target.value);
        var newCurrentValue = utils.updateValue(value, currentValue, distance, index);
        setCurrentValue(newCurrentValue);
        // Trigger change event if needed
        if (onChange) {
            onChange(newCurrentValue);
        }
    };
    var handleInputsContainerMouseDown = function (event) {
        if (trackRef.current === null || event.button !== 0 || disabled) {
            return;
        }
        var target = event.target;
        if (!(target instanceof HTMLInputElement) && target !== trackRef.current) {
            return;
        }
        var clickValue = utils.calculateClickValue(event, trackRef.current, min, max, step, vertical, _isRTL);
        var index = utils.getNearestValueIndex(clickValue, currentValue);
        setIsDragging(true);
        setDragIndex(index);
        updateNearestValue(clickValue);
    };
    var handleLabelClick = function (event, value) {
        if (!clickableLabels || disabled || event.button !== 0) {
            return;
        }
        updateNearestValue(value);
    };
    var handleMouseMove = function (event) {
        if (!isDragging || trackRef.current === null || disabled) {
            return;
        }
        var moveValue = utils.calculateMoveValue(event, trackRef.current, min, max, step, vertical, _isRTL);
        var newCurrentValue = utils.updateValue(moveValue, currentValue, distance, dragIndex);
        setCurrentValue(newCurrentValue);
        if (onChange) {
            onChange(newCurrentValue);
        }
    };
    var handleMouseUp = function () {
        setIsDragging(false);
    };
    return (React.createElement("div", tslib_es6.__assign({ className: index.default('range-slider', className, {
            'range-slider-vertical': vertical,
            disabled: disabled,
        }) }, rest, { ref: forkedRef }),
        React.createElement("div", { className: "range-slider-inputs-container", onMouseDown: handleInputsContainerMouseDown },
            currentValue.map(function (value, index) { return (React.createElement(React.Fragment, { key: index },
                React.createElement("input", { className: "range-slider-input", type: "range", min: min, max: max, step: step, value: value, name: Array.isArray(name) ? name[index] : "".concat(name || '', "-").concat(index, "}"), role: "slider", "aria-valuemin": min, "aria-valuemax": max, "aria-valuenow": value, "aria-orientation": vertical ? 'vertical' : 'horizontal', disabled: disabled, onChange: function (event) { return handleInputChange(event, index); }, ref: function (el) {
                        inputsRef.current[index] = el;
                    } }),
                tooltips && (React.createElement("div", tslib_es6.__assign({ className: "range-slider-tooltip" }, (thumbSize && {
                    style: utils.calculateTooltipPosition(min, max, value, thumbSize, vertical, _isRTL),
                })),
                    React.createElement("div", { className: "range-slider-tooltip-inner" }, tooltipsFormat ? tooltipsFormat(value) : value),
                    React.createElement("div", { className: "range-slider-tooltip-arrow" }))))); }),
            React.createElement("div", tslib_es6.__assign({ className: "range-slider-track" }, (track && {
                style: utils.updateGradient(min, max, currentValue, vertical, _isRTL),
            }), { ref: trackRef }))),
        labels && (React.createElement("div", { className: "range-slider-labels-container", ref: labelsContainerRef }, Array.isArray(labels) &&
            labels.map(function (label, index$1) {
                var labelPosition = utils.calculateLabelPosition(min, max, labels, label, index$1);
                var labelValue = utils.getLabelValue(min, max, labels, label, index$1);
                var labelStyle = Object.assign(vertical
                    ? { bottom: labelPosition }
                    : _isRTL
                        ? { right: labelPosition }
                        : { left: labelPosition }, typeof label === 'object' && 'style' in label && label.style);
                return (React.createElement("div", { className: index.default('range-slider-label', {
                        clickable: clickableLabels,
                    }, typeof label === 'object' && 'className' in label && label.className), style: labelStyle, onMouseDown: function (event) { return handleLabelClick(event, labelValue); }, key: index$1, ref: function (el) {
                        labelsRef.current[index$1] = el;
                    } }, typeof label === 'object' && 'label' in label ? label.label : label));
            })))));
});
CRangeSlider.propTypes = {
    clickableLabels: PropTypes.bool,
    disabled: PropTypes.bool,
    distance: PropTypes.number,
    labels: PropTypes.any,
    max: PropTypes.number,
    min: PropTypes.number,
    name: PropTypes.oneOfType([PropTypes.array, PropTypes.string]),
    step: PropTypes.number,
    tooltips: PropTypes.bool,
    tooltipsFormat: PropTypes.func,
    track: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['fill'])]),
    value: PropTypes.oneOfType([PropTypes.array, PropTypes.number]),
    vertical: PropTypes.bool,
};
CRangeSlider.displayName = 'CRangeSlider';

exports.CRangeSlider = CRangeSlider;
//# sourceMappingURL=CRangeSlider.js.map
