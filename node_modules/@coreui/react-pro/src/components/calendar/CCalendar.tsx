import React, { forwardRef, ReactNode, useEffect, useRef, useState } from 'react'
import PropTypes from 'prop-types'
import classNames from 'classnames'

import { CCalendarNavigation } from './CCalendarNavigation'

import {
  convertToDateObject,
  getCalendarDate,
  getDateBySelectionType,
  getSelectableDates,
  isDateDisabled,
  isDisableDateInRange,
  isSameDateAs,
} from './utils'
import type { DisabledDate, SelectionTypes, ViewTypes } from './types'

import { useForkedRef, useStateWithCallback } from '../../hooks'
import { CCalendarPanel } from './CCalendarPanel'

export interface CCalendarProps {
  /**
   * A string that provides an accessible label for the button that navigates to the next month in the React Calendar component. This label is read by screen readers to describe the action associated with the button. Customize for a more accessible calendar experience.
   *
   * @default 'Next month'
   * @since 5.5.0
   */

  ariaNavNextMonthLabel?: string

  /**
   * A string that provides an accessible label for the button that navigates to the next year in the React Calendar component. Screen readers utilize this label to inform users of the button's functionality, aiding in a more inclusive application.
   *
   * @default 'Next year'
   * @since 5.5.0
   */
  ariaNavNextYearLabel?: string

  /**
   * A string that provides an accessible label for the button that navigates to the previous month in the React Calendar component. This label is announced by screen readers, ensuring clarity around the button's purpose.
   *
   * @default 'Previous month'
   * @since 5.5.0
   */
  ariaNavPrevMonthLabel?: string

  /**
   * A string that provides an accessible label for the button that navigates to the previous year in the React Calendar component. Use it to enhance the experience for screen readers and further accessibility.
   *
   * @default 'Previous year'
   * @since 5.5.0
   */
  ariaNavPrevYearLabel?: string

  /**
   * Defines the initial date or reference date for the React Calendar component. This date can be either a Date object or a string that can be converted into a valid date.
   */
  calendarDate?: Date | string | null

  /**
   * Specifies how many individual calendars should be displayed side by side on desktop devices. Increasing this number allows your users to view multiple months (or years, etc.) simultaneously.
   */
  calendars?: number

  /**
   * A string of all classNames you want to apply to the outermost container of the React Calendar component. Use this to style or theme your calendar.
   */
  className?: string

  /**
   * Sets the format for day names. Accepts either a built-in format ('numeric' or '2-digit') or a custom function to return any desired string or number for the day.
   *
   * @default 'numeric'
   * @since 4.3.0
   */
  dayFormat?: 'numeric' | '2-digit' | ((date: Date) => string | number)

  /**
   * Specifies one or more dates that cannot be selected by the user. This is useful for disabling weekends, holidays, or any dates that you need to restrict within your React Calendar component.
   */
  disabledDates?: DisabledDate | DisabledDate[]

  /**
   * Defines the initially selected ending date (applicable when using range selection). Accepts both Date objects and valid date strings.
   */
  endDate?: Date | string | null

  /**
   * Sets the first day of the week. This can be adjusted for different locales or preferences:
   * - `0` = Sunday
   * - `1` = Monday
   * - `2` = Tuesday
   * - `3` = Wednesday
   * - `4` = Thursday
   * - `5` = Friday
   * - `6` = Saturday
   *
   * @default 1
   */
  firstDayOfWeek?: number

  /**
   * Indicates the locale for the React Calendar component. If not explicitly provided, it inherits the locale settings from the browser.
   *
   * @default 'default'
   */
  locale?: string

  /**
   * The maximum date that can be selected. Any date beyond this value will be disabled within the calendar. This is often used to restrict future selections.
   */
  maxDate?: Date | string | null

  /**
   * The minimum date that can be selected. Any date before this value will be disabled in the calendar. Useful for preventing selection of past dates or creating limited booking windows.
   */
  minDate?: Date | string | null

  /**
   * Toggles display of arrow-based navigation (previous/next controls) in the React Calendar component. If set to `false`, you can build custom navigation or handle the navigation programmatically.
   */
  navigation?: boolean

  /**
   * Customizes the icon for navigating to the next view (month, year, etc.) depending on the current view. Accepts any valid `ReactNode`, enabling you to display text, images, or icons.
   */
  navNextIcon?: ReactNode

  /**
   * Customizes the icon for navigating multiple steps forward (double jump), e.g., skipping multiple months or years at once. Ideal for quick navigation through large date ranges.
   */
  navNextDoubleIcon?: ReactNode

  /**
   * Customizes the icon for navigating to the previous view in the calendar. Accepts any valid ReactNode to provide flexible styling or theming.
   */
  navPrevIcon?: ReactNode

  /**
   * Customizes the icon for a double jump backward (e.g., jumping multiple months or years at once). This feature simplifies larger date range navigation within your React Calendar component.
   */
  navPrevDoubleIcon?: ReactNode

  /**
   * Reorders the year and month navigation, rendering the year selector first. This offers a different layout for users, particularly useful if you want to prioritize quick year changes.
   *
   * @default false
   * @since 4.3.0
   */
  navYearFirst?: boolean

  /**
   * Enables range selection mode in your React Calendar component, allowing users to select two dates for a range (start and end). Once enabled, the component will manage state for both dates.
   */
  range?: boolean

  /**
   * Sets whether days from adjacent months (shown at the start/end of the current view) are selectable. This only applies if `showAdjacementDays` is set to `true`.
   *
   * @default false
   * @since 4.11.0
   */
  selectAdjacementDays?: boolean

  /**
   * Controls whether the calendar should display dates from previous or next months (non-selectable if `selectAdjacementDays` is `false`). This can make the calendar visually continuous.
   *
   * @default true
   * @since 4.11.0
   */
  showAdjacementDays?: boolean

  /**
   * Toggles the display of week numbers (ISO 8601) in the calendar's left column. Particularly beneficial for applications where users need to see the week index for scheduling or reporting.
   *
   * @default false
   * @since 5.0.0
   */
  showWeekNumber?: boolean

  /**
   * Indicates if the user's current selection is targeting the end date in range selection mode. Primarily used for controlled components where you need to manage which date (start or end) is currently active.
   */
  selectEndDate?: boolean

  /**
   * Specifies the selection type for the React Calendar component. Supports:
   * - `day`: Regular day selection (default)
   * - `week`: Select an entire week
   * - `month`: Select an entire month
   * - `year`: Select an entire year
   *
   * @default 'day'
   * @since 5.0.0
   */
  selectionType?: SelectionTypes

  /**
   * Defines the initially selected starting date. This date can be a Date object or a string convertible into a valid date. Useful when you want to show a pre-selected date.
   */
  startDate?: Date | string | null

  /**
   * Sets the format or length of the weekday names displayed in the calendar header. You can use numeric values like 2 (two-letter abbreviations) or built-in string formats like `'long'`, `'narrow'`, and `'short'`, or provide a custom function to fully control how weekdays are displayed.
   *
   * @default 2
   */
  weekdayFormat?: number | 'long' | 'narrow' | 'short' | ((date: Date) => string | number)

  /**
   * Defines the label that appears above the week numbers column. For example, you might label it `'WK'` or `'Week #'`.
   *
   * @since 5.0.0
   */
  weekNumbersLabel?: string

  /**
   * Callback fired when the calendar's reference date (i.e., the date indicating which month/year is currently displayed) changes. Receives the new `Date | string` as an argument for further handling.
   */
  onCalendarDateChange?: (date: Date | string) => void

  /**
   * Callback fired when the user hovers over a calendar cell. The argument is the date of the cell that the user is currently hovering.
   */
  onDateHover?: (date: Date | string | null) => void

  /**
   * Callback triggered when the start date of the selection changes. Useful for updating other parts of your application or performing side effects based on the newly chosen start date.
   */
  onStartDateChange?: (date: Date | string | null, formatedDate?: string | undefined) => void

  /**
   * Callback triggered when the end date of the selection changes. Handy for synchronizing the selected date range with external states or components.
   */
  onEndDateChange?: (date: Date | string | null, formatedDate?: string | undefined) => void

  /**
   * Callback fired when toggling between selecting the start date and the end date in range selection mode. Receives a boolean indicating if the user is currently selecting the end date.
   */
  onSelectEndChange?: (value: boolean) => void

  /**
   * Callback fired when the calendar's view changes between days, months, or years. For instance, moving from day view to month view or from month view to year view.
   */
  onViewChanged?: (view: string) => void
}

export const CCalendar = forwardRef<HTMLDivElement, CCalendarProps>(
  (
    {
      ariaNavNextMonthLabel = 'Next month',
      ariaNavNextYearLabel = 'Next year',
      ariaNavPrevMonthLabel = 'Previous month',
      ariaNavPrevYearLabel = 'Previous year',
      startDate,
      endDate,
      calendarDate = startDate || endDate || null,
      calendars = 1,
      className,
      dayFormat = 'numeric',
      disabledDates,
      firstDayOfWeek = 1,
      locale = 'default',
      maxDate,
      minDate,
      navigation = true,
      navNextIcon,
      navNextDoubleIcon,
      navPrevIcon,
      navPrevDoubleIcon,
      navYearFirst,
      range,
      selectAdjacementDays = false,
      selectEndDate,
      selectionType = 'day',
      showAdjacementDays = true,
      showWeekNumber = false,
      weekdayFormat = 2,
      weekNumbersLabel,
      onCalendarDateChange,
      onDateHover,
      onEndDateChange,
      onStartDateChange,
      onSelectEndChange,
      onViewChanged,
    },
    ref,
  ) => {
    const calendarRef = useRef<HTMLDivElement>(null)
    const forkedRef = useForkedRef(ref, calendarRef)
    const isInitialMount = useRef(true)
    const [_calendarDate, setCalendarDate] = useState<Date | null>(null)

    useEffect(() => {
      const viewMap = {
        day: 'days',
        week: 'days',
        month: 'months',
        year: 'years',
      }

      setView((viewMap[selectionType] as ViewTypes) || 'days')
    }, [selectionType])

    useEffect(() => {
      if (calendarDate === null) {
        setCalendarDate(new Date())
        return
      }

      if (calendarDate) {
        const date = convertToDateObject(calendarDate, selectionType)
        !isSameDateAs(_calendarDate, date) && setCalendarDate(date)
      }
    }, [calendarDate])

    const [_startDate, setStartDate] = useStateWithCallback<Date | null>(
      startDate ? convertToDateObject(startDate, selectionType) : null,
      () =>
        onStartDateChange && onStartDateChange(getDateBySelectionType(_startDate, selectionType)),
      !isInitialMount.current,
    )
    useEffect(() => {
      const date = startDate ? convertToDateObject(startDate, selectionType) : null
      if (!isSameDateAs(date, _startDate)) {
        setStartDate(date)
      }
    }, [startDate])

    const [_endDate, setEndDate] = useStateWithCallback<Date | null>(
      endDate ? convertToDateObject(endDate, selectionType) : null,
      () => onEndDateChange && onEndDateChange(getDateBySelectionType(_endDate, selectionType)),
      !isInitialMount.current,
    )
    useEffect(() => {
      const date = endDate ? convertToDateObject(endDate, selectionType) : null
      if (!isSameDateAs(date, _endDate)) {
        setEndDate(date)
      }
    }, [endDate])

    const [_hoverDate, setHoverDate] = useState<Date | null>(null)

    const [_maxDate, setMaxDate] = useState<Date | null>(
      maxDate ? convertToDateObject(maxDate, selectionType) : null,
    )
    useEffect(() => {
      maxDate && setMaxDate(convertToDateObject(maxDate, selectionType))
    }, [maxDate])

    const [_minDate, setMinDate] = useState<Date | null>(
      minDate ? convertToDateObject(minDate, selectionType) : null,
    )
    useEffect(() => {
      minDate && setMinDate(convertToDateObject(minDate, selectionType))
    }, [minDate])

    const [_selectEndDate, setSelectEndDate] = useStateWithCallback(
      selectEndDate,
      onSelectEndChange,
    )
    useEffect(() => {
      setSelectEndDate(selectEndDate)
    }, [selectEndDate])

    useEffect(() => {
      if (!isInitialMount.current && typeof _selectEndDate === 'boolean') {
        onSelectEndChange?.(_selectEndDate)
      }
    }, [_selectEndDate])

    const [view, setView] = useStateWithCallback<ViewTypes>('days', onViewChanged)
    const [focusOn, setFocusOn] = useState<number | undefined>()

    useEffect(() => {
      if (typeof focusOn === 'number') {
        const list = getSelectableDates(calendarRef.current as HTMLDivElement)
        list[focusOn]?.focus()
        setFocusOn(undefined)
      }
    }, [view])

    useEffect(() => {
      isInitialMount.current = false
    }, [])

    const setCalendarPage = (years: number, months = 0, setMonth?: number) => {
      if (_calendarDate === null) {
        return
      }

      const year = _calendarDate.getFullYear()
      const month = _calendarDate.getMonth()
      const d = new Date(year, month, 1)

      if (years) {
        d.setFullYear(d.getFullYear() + years)
      }

      if (months) {
        d.setMonth(d.getMonth() + months)
      }

      if (typeof setMonth === 'number') {
        d.setMonth(setMonth)
      }

      setCalendarDate(d)
      onCalendarDateChange?.(d)
    }

    const handleCalendarClick = (date: Date, index?: number) => {
      const _date = new Date(date)

      if (view === 'days') {
        setCalendarDate(index ? new Date(_date.setMonth(_date.getMonth() - index)) : _date)
      }

      if (view === 'months' && selectionType !== 'month') {
        setCalendarDate(index ? new Date(_date.setMonth(_date.getMonth() - index)) : _date)
        setView('days')
        return
      }

      if (view === 'years' && selectionType !== 'year') {
        setCalendarDate(index ? new Date(_date.setFullYear(_date.getFullYear() - index)) : _date)
        setView('months')
        return
      }

      // Allow to change the calendarDate but not startDate or endDate
      if (isDateDisabled(date, _minDate, _maxDate, disabledDates)) {
        return
      }

      if (range) {
        if (_selectEndDate) {
          setSelectEndDate(false)

          if (_startDate && _startDate > date) {
            setStartDate(null)
            setEndDate(null)
            return
          }

          if (isDisableDateInRange(_startDate, date, disabledDates)) {
            setStartDate(null)
            setEndDate(null)
            return
          }

          setEndDate(date)
          return
        }

        if (_endDate && _endDate < date) {
          setStartDate(null)
          setEndDate(null)
          return
        }

        if (isDisableDateInRange(date, _endDate, disabledDates)) {
          setStartDate(null)
          setEndDate(null)
          return
        }

        setSelectEndDate(true)
        setStartDate(date)
        return
      }

      setStartDate(date)
    }

    const handleCalendarKeyDown = (
      event: React.KeyboardEvent<HTMLDivElement>,
      date: Date,
      index?: number,
    ) => {
      if (event.code === 'Space' || event.key === 'Enter') {
        event.preventDefault()
        if (
          (view === 'months' && selectionType !== 'month') ||
          (view === 'years' && selectionType !== 'year')
        ) {
          setFocusOn(0)
        }

        handleCalendarClick(date, index)
      }

      if (
        event.key === 'ArrowRight' ||
        event.key === 'ArrowLeft' ||
        event.key === 'ArrowUp' ||
        event.key === 'ArrowDown'
      ) {
        event.preventDefault()

        if (
          _maxDate &&
          date >= _maxDate &&
          (event.key === 'ArrowRight' || event.key === 'ArrowDown')
        ) {
          return
        }

        if (
          _minDate &&
          date <= _minDate &&
          (event.key === 'ArrowLeft' || event.key === 'ArrowUp')
        ) {
          return
        }

        let element = event.target as HTMLElement

        if (selectionType === 'week' && element.tabIndex === -1) {
          element = element.closest('tr[tabindex="0"]') as HTMLElement
        }

        const list: HTMLElement[] = getSelectableDates(calendarRef.current as HTMLDivElement)

        const index = list.indexOf(element)
        const first = index === 0
        const last = index === list.length - 1

        const toBoundary = {
          start: index,
          end: list.length - (index + 1),
        }

        const gap = {
          ArrowRight: 1,
          ArrowLeft: -1,
          ArrowUp: selectionType === 'week' && view === 'days' ? -1 : view === 'days' ? -7 : -3,
          ArrowDown: selectionType === 'week' && view === 'days' ? 1 : view === 'days' ? 7 : 3,
        }

        if (
          (event.key === 'ArrowRight' && last) ||
          (event.key === 'ArrowDown' && toBoundary['end'] < gap['ArrowDown']) ||
          (event.key === 'ArrowLeft' && first) ||
          (event.key === 'ArrowUp' && toBoundary['start'] < Math.abs(gap['ArrowUp']))
        ) {
          if (view === 'days') {
            setCalendarPage(0, event.key === 'ArrowRight' || event.key === 'ArrowDown' ? 1 : -1)
          }

          if (view === 'months') {
            setCalendarPage(event.key === 'ArrowRight' || event.key === 'ArrowDown' ? 1 : -1)
          }

          if (view === 'years') {
            setCalendarPage(event.key === 'ArrowRight' || event.key === 'ArrowDown' ? 10 : -10)
          }

          setTimeout(() => {
            const _list = getSelectableDates(element.parentNode?.parentNode as HTMLDivElement)

            if (_list.length > 0 && event.key === 'ArrowRight') {
              _list[0].focus()
            }

            if (_list.length > 0 && event.key === 'ArrowLeft') {
              _list.at(-1)?.focus()
            }

            if (_list.length > 0 && event.key === 'ArrowDown') {
              _list[gap['ArrowDown'] - (list.length - index)].focus()
            }

            if (_list.length > 0 && event.key === 'ArrowUp') {
              _list[_list.length - (Math.abs(gap['ArrowUp']) + 1 - (index + 1))].focus()
            }
          }, 1)

          return
        }

        if (list[index + gap[event.key]].tabIndex === 0) {
          list[index + gap[event.key]].focus()
          return
        }

        for (
          let i = index;
          i < list.length;
          event.key === 'ArrowRight' || event.key === 'ArrowDown' ? i++ : i--
        ) {
          if (list[i + gap[event.key]].tabIndex === 0) {
            list[i + gap[event.key]].focus()
            break
          }
        }
      }
    }

    const handleCalendarMouseEnter = (date: Date) => {
      if (isDateDisabled(date, _minDate, _maxDate, disabledDates)) {
        return
      }

      setHoverDate(date)

      if (date) {
        onDateHover?.(getDateBySelectionType(date, selectionType))
      }
    }

    const handleCalendarMouseLeave = () => {
      setHoverDate(null)
      onDateHover?.(null)
    }

    const handleNavigationOnClick = (direction: string, double = false) => {
      if (direction === 'prev') {
        if (double) {
          setCalendarPage(view === 'years' ? -10 : -1)
          return
        }

        if (view !== 'days') {
          setCalendarPage(-1)
          return
        }

        setCalendarPage(0, -1)
        return
      }

      if (direction === 'next') {
        if (double) {
          setCalendarPage(view === 'years' ? 10 : 1)
          return
        }

        if (view !== 'days') {
          setCalendarPage(1)
          return
        }

        setCalendarPage(0, 1)
        return
      }
    }

    return (
      <div
        className={classNames(
          'calendars',
          {
            [`select-${selectionType}`]: selectionType && view === 'days',
            'show-week-numbers': showWeekNumber,
          },
          className,
        )}
        ref={forkedRef}
      >
        {_calendarDate &&
          Array.from({ length: calendars }, (_, index) => {
            const calendarDate = getCalendarDate(_calendarDate, index, view)
            return (
              <div className={classNames('calendar', view)} key={index}>
                <CCalendarNavigation
                  ariaNavNextMonthLabel={ariaNavNextMonthLabel}
                  ariaNavNextYearLabel={ariaNavNextYearLabel}
                  ariaNavPrevMonthLabel={ariaNavPrevMonthLabel}
                  ariaNavPrevYearLabel={ariaNavPrevYearLabel}
                  calendarDate={calendarDate}
                  locale={locale}
                  navigation={navigation}
                  navNextDoubleIcon={navNextDoubleIcon}
                  navNextIcon={navNextIcon}
                  navPrevDoubleIcon={navPrevDoubleIcon}
                  navPrevIcon={navPrevIcon}
                  navYearFirst={navYearFirst}
                  onMonthClick={() => setView('months')}
                  onNavigationClick={handleNavigationOnClick}
                  onYearClick={() => setView('years')}
                  view={view}
                />
                <CCalendarPanel
                  calendarDate={calendarDate}
                  dayFormat={dayFormat}
                  disabledDates={disabledDates}
                  endDate={_endDate}
                  firstDayOfWeek={firstDayOfWeek}
                  hoverDate={_hoverDate}
                  locale={locale}
                  maxDate={_maxDate}
                  minDate={_minDate}
                  onCalendarClick={(date) => handleCalendarClick(date, index)}
                  onCalendarKeyDown={(event, date) => handleCalendarKeyDown(event, date, index)}
                  onCalendarMouseEnter={handleCalendarMouseEnter}
                  onCalendarMouseLeave={handleCalendarMouseLeave}
                  order={index}
                  selectAdjacementDays={selectAdjacementDays}
                  selectEndDate={_selectEndDate}
                  selectionType={selectionType}
                  showAdjacementDays={showAdjacementDays}
                  showWeekNumber={showWeekNumber}
                  startDate={_startDate}
                  view={view}
                  weekdayFormat={weekdayFormat}
                  weekNumbersLabel={weekNumbersLabel}
                />
              </div>
            )
          })}
      </div>
    )
  },
)

CCalendar.propTypes = {
  ariaNavNextMonthLabel: PropTypes.string,
  ariaNavNextYearLabel: PropTypes.string,
  ariaNavPrevMonthLabel: PropTypes.string,
  ariaNavPrevYearLabel: PropTypes.string,
  className: PropTypes.string,
  calendarDate: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string]),
  calendars: PropTypes.number,
  dayFormat: PropTypes.oneOfType([
    PropTypes.func,
    PropTypes.oneOf<'2-digit' | 'numeric'>(['2-digit', 'numeric']),
  ]),
  disabledDates: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.array, PropTypes.func]),
  endDate: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string]),
  firstDayOfWeek: PropTypes.number,
  locale: PropTypes.string,
  maxDate: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string]),
  minDate: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string]),
  navigation: PropTypes.bool,
  navNextIcon: PropTypes.node,
  navNextDoubleIcon: PropTypes.node,
  navPrevIcon: PropTypes.node,
  navPrevDoubleIcon: PropTypes.node,
  navYearFirst: PropTypes.bool,
  range: PropTypes.bool,
  selectAdjacementDays: PropTypes.bool,
  selectEndDate: PropTypes.bool,
  selectionType: PropTypes.oneOf(['day', 'week', 'month', 'year']),
  showAdjacementDays: PropTypes.bool,
  showWeekNumber: PropTypes.bool,
  startDate: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string]),
  weekdayFormat: PropTypes.oneOfType([
    PropTypes.func,
    PropTypes.number,
    PropTypes.oneOf<'long' | 'narrow' | 'short'>(['long', 'narrow', 'short']),
  ]),
  weekNumbersLabel: PropTypes.string,
  onDateHover: PropTypes.func,
  onCalendarDateChange: PropTypes.func,
  onEndDateChange: PropTypes.func,
  onSelectEndChange: PropTypes.func,
  onStartDateChange: PropTypes.func,
  onViewChanged: PropTypes.func,
}

CCalendar.displayName = 'CCalendar'
