'use strict';

var tslib_es6 = require('../../node_modules/tslib/tslib.es6.js');

var calculateClickValue = function (event, container, min, max, step, vertical, rtl) {
    var clickPosition = getClickPosition(event, container, vertical, rtl);
    var value = min + clickPosition * (max - min);
    return roundToStep(value, step);
};
var calculateMoveValue = function (event, container, min, max, step, vertical, rtl) {
    var rect = container.getBoundingClientRect();
    var position = vertical
        ? calculateVerticalPosition(event.clientY, rect)
        : calculateHorizontalPosition(event.clientX, rect, rtl);
    if (typeof position === 'string') {
        return position === 'max' ? max : min;
    }
    var value = min + position * (max - min);
    return roundToStep(value, step);
};
var calculateVerticalPosition = function (mouseY, rect) {
    if (mouseY < rect.top) {
        return 'max';
    }
    if (mouseY > rect.bottom) {
        return 'min';
    }
    return Math.min(Math.max((rect.bottom - mouseY) / rect.height, 0), 1);
};
var calculateHorizontalPosition = function (mouseX, rect, rtl) {
    if (mouseX < rect.left) {
        return rtl ? 'max' : 'min';
    }
    if (mouseX > rect.right) {
        return rtl ? 'min' : 'max';
    }
    var relativeX = rtl ? rect.right - mouseX : mouseX - rect.left;
    return Math.min(Math.max(relativeX / rect.width, 0), 1);
};
var calculateLabelPosition = function (min, max, labels, label, index) {
    if (typeof label === 'object' && 'value' in label) {
        return "".concat(((label.value - min) / (max - min)) * 100, "%");
    }
    return "".concat((index / (labels.length - 1)) * 100, "%");
};
var calculateTooltipPosition = function (min, max, value, thumbSize, vertical, rtl) {
    var percent = (value - min) / (max - min);
    var margin = percent > 0.5
        ? "-".concat((percent - 0.5) * thumbSize.value).concat(thumbSize.unit)
        : "".concat((0.5 - percent) * thumbSize.value).concat(thumbSize.unit);
    if (vertical) {
        return {
            bottom: "".concat(percent * 100, "%"),
            marginBottom: margin,
        };
    }
    return rtl
        ? { right: "".concat(percent * 100, "%"), marginRight: margin }
        : { left: "".concat(percent * 100, "%"), marginLeft: margin };
};
var getClickPosition = function (event, container, vertical, rtl) {
    // MouseEvent doesn't have `offsetX`/`offsetY`, so we need to use `event.nativeEvent` instead
    var _a = event.nativeEvent, offsetX = _a.offsetX, offsetY = _a.offsetY;
    var offsetWidth = container.offsetWidth, offsetHeight = container.offsetHeight;
    if (vertical) {
        return 1 - offsetY / offsetHeight;
    }
    return rtl ? 1 - offsetX / offsetWidth : offsetX / offsetWidth;
};
var getLabelValue = function (min, max, labels, label, index) {
    return typeof label === 'object' && 'value' in label
        ? label.value
        : min + (index / (labels.length - 1)) * (max - min);
};
var getNearestValueIndex = function (value, values) {
    var valuesLength = values.length;
    if (value < values[0]) {
        return 0;
    }
    if (value > values[valuesLength - 1]) {
        return valuesLength - 1;
    }
    var distances = values.map(function (v) { return Math.abs(v - value); });
    var min = Math.min.apply(Math, distances);
    var firstIndex = distances.indexOf(min);
    return value < values[firstIndex] ? firstIndex : distances.lastIndexOf(min);
};
var getThumbSize = function (element, vertical) {
    var value = globalThis
        .getComputedStyle(element, null)
        .getPropertyValue(vertical ? '--cui-range-slider-thumb-height' : '--cui-range-slider-thumb-width');
    var regex = /^(\d+\.?\d*)([%a-z]*)$/i;
    var match = value.match(regex);
    if (match) {
        return {
            value: Number.parseFloat(match[1]),
            unit: match[2] || null,
        };
    }
    return null;
};
var roundToStep = function (number, step) {
    var _step = step === 0 ? 1 : step;
    return Math.round(number / _step) * _step;
};
var updateGradient = function (min, max, values, vertical, rtl) {
    var minVal = Math.min.apply(Math, values);
    var maxVal = Math.max.apply(Math, values);
    var from = ((minVal - min) / (max - min)) * 100;
    var to = ((maxVal - min) / (max - min)) * 100;
    var direction = vertical ? 'to top' : rtl ? 'to left' : 'to right';
    return {
        backgroundImage: values.length === 1
            ? "linear-gradient(\n    ".concat(direction, ",\n    var(--cui-range-slider-track-in-range-bg) 0%,\n    var(--cui-range-slider-track-in-range-bg) ").concat(to, "%,\n    transparent ").concat(to, "%,\n    transparent 100%\n  )")
            : "linear-gradient(\n    ".concat(direction, ",\n    transparent 0%,\n    transparent ").concat(from, "%,\n    var(--cui-range-slider-track-in-range-bg) ").concat(from, "%,\n    var(--cui-range-slider-track-in-range-bg) ").concat(to, "%,\n    transparent ").concat(to, "%,\n    transparent 100%\n  )"),
    };
};
var updateValue = function (value, values, distance, index) {
    var newValue = tslib_es6.__spreadArray([], values, true);
    newValue[index] = validateValue(value, values, distance, index);
    return newValue;
};
var validateValue = function (value, values, distance, index) {
    // If there's only one value, return it as is
    if (values.length === 1) {
        return value;
    }
    // Determine previous and next values if they exist
    var prevValue = index > 0 ? values[index - 1] : undefined;
    var nextValue = index < values.length - 1 ? values[index + 1] : undefined;
    // If it's the first element, ensure it's not too close to the next value
    if (index === 0 && nextValue !== undefined) {
        return Math.min(value, nextValue - distance);
    }
    // If it's the last element, ensure it's not too close to the previous value
    if (index === values.length - 1 && prevValue !== undefined) {
        return Math.max(value, prevValue + distance);
    }
    // For middle elements, ensure the value is within the allowed distance from both neighbors
    if (prevValue !== undefined && nextValue !== undefined) {
        var minVal = prevValue + distance;
        var maxVal = nextValue - distance;
        return Math.min(Math.max(value, minVal), maxVal);
    }
    // Fallback: If for some reason prevValue or nextValue is undefined, return the original value
    return value;
};

exports.calculateClickValue = calculateClickValue;
exports.calculateHorizontalPosition = calculateHorizontalPosition;
exports.calculateLabelPosition = calculateLabelPosition;
exports.calculateMoveValue = calculateMoveValue;
exports.calculateTooltipPosition = calculateTooltipPosition;
exports.calculateVerticalPosition = calculateVerticalPosition;
exports.getClickPosition = getClickPosition;
exports.getLabelValue = getLabelValue;
exports.getNearestValueIndex = getNearestValueIndex;
exports.getThumbSize = getThumbSize;
exports.roundToStep = roundToStep;
exports.updateGradient = updateGradient;
exports.updateValue = updateValue;
exports.validateValue = validateValue;
//# sourceMappingURL=utils.js.map
